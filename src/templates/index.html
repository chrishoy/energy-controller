<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Rates</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script>
        // Register the annotation plugin
        Chart.register(ChartAnnotation);
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .current-rate {
            background-color: #f0f0f0;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .chart-container {
            margin-top: 20px;
            height: 400px;
            width: 100%;
            position: relative;
        }
    </style>
</head>

<body>
    <div class="current-rate">
        <p>Current Price inc. VAT: <span id="current-price">Loading...</span> p/kWh</p>
        <p>As At: <span id="as-at">Loading...</span></p>
        <p>Valid Until: <span id="valid-until">Loading...</span></p>
        <p>Rates Read: <span id="rates-updated">Loading...</span></p>
    </div>

    <div class="heating-schedule"
        style="background-color: #f8f9fa; padding: 20px; border-radius: 5px; margin-bottom: 20px;">
        <h3>Optimized Heating Schedule</h3>
        <div id="heating-summary">Loading heating schedule...</div>
    </div>
    <div class="chart-container">
        <canvas id="ratesChart"></canvas>
    </div>

    <script>
        // Function to format date string
        function formatDate(dateString) {
            return new Date(dateString).toLocaleString();
        }

        // Function to generate heating periods for background fill
        function generateHeatingPeriods(heatingData, rateData) {
            const periods = [];

            if (!heatingData.transitions || !rateData.latest) {
                return periods;
            }

            let currentHeatingState = false;
            let periodStart = null;

            // Create a map of heating states for each time slot
            const heatingStates = new Map();

            heatingData.transitions.forEach(transition => {
                const transitionTime = new Date(transition.time);
                const transitionTimeMs = transitionTime.getTime();

                // Find the index in rateData.latest that corresponds to this transition
                let rateIndex = rateData.latest.findIndex(rate => {
                    const rateTime = new Date(rate.valid_from).getTime();
                    return rateTime >= transitionTimeMs;
                });

                if (rateIndex === -1) rateIndex = rateData.latest.length - 1;

                // Set heating state for this time and all subsequent times until next transition
                for (let i = rateIndex; i < rateData.latest.length; i++) {
                    heatingStates.set(i, transition.on);
                }
            });

            // Create background fill datasets for heating periods
            let currentPeriod = null;
            for (let i = 0; i < rateData.latest.length; i++) {
                const isHeating = heatingStates.get(i) || false;

                if (isHeating && !currentPeriod) {
                    // Start of heating period
                    currentPeriod = {
                        label: 'Heating Period',
                        data: new Array(rateData.latest.length).fill(null),
                        backgroundColor: 'rgba(40, 167, 69, 0.12)', // Very light green background
                        borderColor: 'rgba(40, 167, 69, 0.2)',
                        borderWidth: 0,
                        fill: 'origin',
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0,
                        stepped: 'before',
                        showLine: false // Hide the line, only show fill
                    };
                } else if (!isHeating && currentPeriod) {
                    // End of heating period
                    periods.push(currentPeriod);
                    currentPeriod = null;
                }

                if (currentPeriod) {
                    currentPeriod.data[i] = rateData.latest[i].value_inc_vat;
                }
            }

            // Add final period if it ends with heating
            if (currentPeriod) {
                periods.push(currentPeriod);
            }

            return periods;
        }

        // Function to generate heating schedule annotations
        function generateHeatingAnnotations(heatingData, rateData) {
            const annotations = {};

            if (!heatingData.transitions || !rateData.latest) {
                return annotations;
            }

            heatingData.transitions.forEach((transition, index) => {
                const transitionTime = new Date(transition.time);
                const transitionTimeMs = transitionTime.getTime();

                // Find the index in rateData.latest that corresponds to this transition
                let rateIndex = rateData.latest.findIndex(rate => {
                    const rateTime = new Date(rate.valid_from).getTime();
                    return rateTime >= transitionTimeMs;
                });

                if (rateIndex === -1) rateIndex = rateData.latest.length - 1;

                const annotationKey = `heating_${index}`;
                annotations[annotationKey] = {
                    type: 'line',
                    scaleID: 'x',
                    value: rateIndex,
                    borderColor: transition.on ? '#28a745' : '#dc3545',
                    borderWidth: 1,
                    borderDash: transition.on ? [] : [3, 3],
                    label: {
                        display: transition.on, // Only show labels for Heating ON
                        content: transition.on ? transition.price.toFixed(2) + 'p' : '',
                        position: 'end',
                        backgroundColor: transition.on ? '#28a745' : 'transparent',
                        color: 'white',
                        font: {
                            size: 9,
                            weight: 'bold'
                        }
                    }
                };
            });

            return annotations;
        }

        // Function to update the rates display
        function updateRates() {
            console.log('Fetching updated rates...');
            Promise.all([
                fetch('/api/rates').then(response => response.json()),
                fetch('/api/heating-schedule').then(response => response.json())
            ])
                .then(([rateData, heatingData]) => {
                    console.log('Received new rate data:', rateData);
                    console.log('Received heating schedule:', heatingData);
                    // Update current rate
                    if (rateData.current) {
                        document.getElementById('current-price').textContent =
                            rateData.current.value_inc_vat.toFixed(2);
                        document.getElementById('as-at').textContent =
                            formatDate(rateData.as_at);
                        document.getElementById('valid-until').textContent =
                            formatDate(rateData.current.valid_to);
                        document.getElementById('rates-updated').textContent =
                            formatDate(rateData.data_read_at);
                    }

                    // Update heating schedule summary
                    if (heatingData.summary) {
                        const summary = heatingData.summary;
                        document.getElementById('heating-summary').innerHTML = `
                            <p><strong>Total Cost:</strong> Â£${summary.total_cost.toFixed(3)}</p>
                            <p><strong>Heating Hours:</strong> ${summary.on_hours.toFixed(1)} hours</p>
                            <p><strong>Average Price When On:</strong> ${summary.average_on_price ? summary.average_on_price.toFixed(2) : 'N/A'} p/kWh</p>
                            <p><strong>Comfort Coverage:</strong> ${summary.warm_comfort_slots}/${summary.comfort_slots} slots</p>
                            <p><strong>Total Transitions:</strong> ${heatingData.transitions ? heatingData.transitions.length : 0}</p>
                        `;
                    }

                    // Update chart
                    console.log('Creating chart with', rateData.latest.length, 'data points');
                    const timeLabels = rateData.latest.map(rate => {
                        const date = new Date(rate.valid_from);
                        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    });
                    const values = rateData.latest.map(rate => rate.value_inc_vat);
                    console.log('Chart data prepared:', { timeLabels: timeLabels.length, values: values.length });

                    // Destroy existing chart if it exists
                    if (window.rateChart) {
                        window.rateChart.destroy();
                    }

                    const canvas = document.getElementById('ratesChart');
                    if (!canvas) {
                        console.error('Canvas element not found!');
                        return;
                    }
                    const ctx = canvas.getContext('2d');
                    console.log('Chart context created, creating chart...');
                    console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
                    // Create heating periods data for background fill
                    const heatingPeriods = generateHeatingPeriods(heatingData, rateData);

                    window.rateChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: timeLabels,
                            datasets: [
                                // Heating background areas
                                ...heatingPeriods,
                                // Main price line
                                {
                                    label: 'Rate (p/kWh)',
                                    data: values,
                                    borderColor: 'rgb(75, 192, 192)',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    stepped: 'before',  // This creates the step effect
                                    pointRadius: 1,     // Small points at the corners
                                    pointHoverRadius: 5,
                                    fill: false,
                                    tension: 0
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: false
                                },
                                x: {
                                    title: {
                                        display: false
                                    },
                                    ticks: {
                                        callback: function (value, index) {
                                            return timeLabels[index];
                                        }
                                    },
                                    grid: {
                                        display: false  // Remove vertical grid lines
                                    },
                                    // Add extra padding at bottom for date labels
                                    afterFit: function (scale) {
                                        scale.paddingBottom = 35;  // Adjusted padding for date labels
                                    }
                                },
                                x2: {
                                    type: 'category',
                                    position: 'bottom',
                                    grid: {
                                        display: false  // Remove vertical grid lines
                                    },
                                    border: {
                                        display: false
                                    },
                                    ticks: {
                                        maxRotation: 0,
                                        minRotation: 0,
                                        padding: 15,  // Adjusted padding for better spacing
                                        autoSkip: false,  // Don't skip any ticks
                                        callback: function (value, index) {
                                            if (!rateData.latest || index >= rateData.latest.length) return '';

                                            const date = new Date(rateData.latest[index].valid_from);
                                            const currentDay = date.getDate();

                                            // Find the start and end indices for the current date
                                            let firstIndex = index;
                                            let lastIndex = index;

                                            // Look backwards to find first entry for this date
                                            while (firstIndex > 0 &&
                                                new Date(rateData.latest[firstIndex - 1].valid_from).getDate() === currentDay) {
                                                firstIndex--;
                                            }

                                            // Look forwards to find last entry for this date
                                            while (lastIndex < rateData.latest.length - 1 &&
                                                new Date(rateData.latest[lastIndex + 1].valid_from).getDate() === currentDay) {
                                                lastIndex++;
                                            }

                                            // Show markers at actual first and last data points for the date
                                            if (index === firstIndex || index === lastIndex) {
                                                return '|';
                                            }

                                            // Show date label at center point between first and last actual data points
                                            const centerIndex = Math.floor((firstIndex + lastIndex) / 2);
                                            if (index === centerIndex) {
                                                return date.toLocaleDateString([],
                                                    { weekday: 'short', month: 'short', day: 'numeric' });
                                            }

                                            return '';
                                        }
                                    }
                                }
                            },
                            animation: {
                                duration: 0 // Disable animation for smoother updates
                            },
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 20
                                    }
                                },
                                annotation: {
                                    annotations: {
                                        currentTime: {
                                            type: 'line',
                                            scaleID: 'x',
                                            value: function (ctx) {
                                                const asAtDate = new Date(rateData.as_at);
                                                const asAtTime = asAtDate.getTime();

                                                // Find the surrounding time points
                                                let nextIndex = rateData.latest.findIndex(rate =>
                                                    new Date(rate.valid_from).getTime() > asAtTime
                                                );
                                                if (nextIndex === -1) nextIndex = rateData.latest.length;
                                                const prevIndex = nextIndex - 1;

                                                if (prevIndex < 0) return 0;  // Before first point
                                                if (nextIndex >= rateData.latest.length) return rateData.latest.length - 1;  // After last point

                                                // Calculate interpolation
                                                const prevTime = new Date(rateData.latest[prevIndex].valid_from).getTime();
                                                const nextTime = new Date(rateData.latest[nextIndex].valid_from).getTime();
                                                const fraction = (asAtTime - prevTime) / (nextTime - prevTime);

                                                // Return interpolated position
                                                return prevIndex + fraction;
                                            },
                                            borderColor: 'red',
                                            borderWidth: 2,
                                            label: {
                                                display: true,
                                                content: 'Current Time: ' + new Date(rateData.as_at).toLocaleTimeString([],
                                                    { hour: '2-digit', minute: '2-digit' }),
                                                position: 'top'
                                            }
                                        },
                                        ...generateHeatingAnnotations(heatingData, rateData)
                                    }
                                }
                            }
                        }
                    });
                    console.log('Chart created successfully');
                    console.log('Chart instance:', window.rateChart);
                })
                .catch(error => {
                    console.error('Error fetching rates:', error);
                });
            console.log('Update cycle completed');
        }

        // Update rates immediately and then every 5 minutes
        updateRates();
        setInterval(updateRates, 300000);
    </script>
</body>

</html>